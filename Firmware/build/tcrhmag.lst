
build/tcrhmag.elf:     file format elf32-littleriscv


Disassembly of section .init:

00000000 <InterruptVector>:
	void InterruptVector()         __attribute__((naked)) __attribute((section(".init"))) __attribute((weak,alias("InterruptVectorDefault"))) __attribute((naked));
	void InterruptVectorDefault()  __attribute__((naked)) __attribute((section(".init"))) __attribute((naked));
	void InterruptVectorDefault( void )
	{
		#if !defined(FUNCONF_TINYVECTOR) || !FUNCONF_TINYVECTOR
			asm volatile( DEFAULT_INTERRUPT_VECTOR_CONTENTS );
   0:	44a0006f          	j	44a <handle_reset>
   4:	00000000          	.word	0x00000000
   8:	00000506          	.word	0x00000506
   c:	000004ba          	.word	0x000004ba
	...
  30:	0000090e          	.word	0x0000090e
  34:	00000000          	.word	0x00000000
  38:	000004ba          	.word	0x000004ba
  3c:	00000000          	.word	0x00000000
  40:	000004ba          	.word	0x000004ba
  44:	000004ba          	.word	0x000004ba
  48:	000004ba          	.word	0x000004ba
  4c:	000004ba          	.word	0x000004ba
  50:	000004ba          	.word	0x000004ba
  54:	000004ba          	.word	0x000004ba
  58:	000004ba          	.word	0x000004ba
  5c:	000004ba          	.word	0x000004ba
  60:	000004ba          	.word	0x000004ba
  64:	000004ba          	.word	0x000004ba
  68:	000004ba          	.word	0x000004ba
  6c:	000004ba          	.word	0x000004ba
  70:	000004ba          	.word	0x000004ba
  74:	000004ba          	.word	0x000004ba
  78:	000004ba          	.word	0x000004ba
  7c:	000004ba          	.word	0x000004ba
  80:	000004ba          	.word	0x000004ba
  84:	000004ba          	.word	0x000004ba
  88:	000004ba          	.word	0x000004ba
  8c:	000004ba          	.word	0x000004ba
  90:	000004ba          	.word	0x000004ba
  94:	000004ba          	.word	0x000004ba
  98:	000004ba          	.word	0x000004ba
  9c:	0000                	unimp
	...

Disassembly of section .text:

000000a0 <__divsi3>:
  a0:	02054e63          	bltz	a0,dc <__umodsi3+0x8>
  a4:	0405c363          	bltz	a1,ea <__umodsi3+0x16>

000000a8 <__hidden___udivsi3>:
  a8:	862e                	mv	a2,a1
  aa:	85aa                	mv	a1,a0
  ac:	557d                	li	a0,-1
  ae:	c215                	beqz	a2,d2 <__hidden___udivsi3+0x2a>
  b0:	4685                	li	a3,1
  b2:	00b67863          	bgeu	a2,a1,c2 <__hidden___udivsi3+0x1a>
  b6:	00c05663          	blez	a2,c2 <__hidden___udivsi3+0x1a>
  ba:	0606                	slli	a2,a2,0x1
  bc:	0686                	slli	a3,a3,0x1
  be:	feb66ce3          	bltu	a2,a1,b6 <__hidden___udivsi3+0xe>
  c2:	4501                	li	a0,0
  c4:	00c5e463          	bltu	a1,a2,cc <__hidden___udivsi3+0x24>
  c8:	8d91                	sub	a1,a1,a2
  ca:	8d55                	or	a0,a0,a3
  cc:	8285                	srli	a3,a3,0x1
  ce:	8205                	srli	a2,a2,0x1
  d0:	faf5                	bnez	a3,c4 <__hidden___udivsi3+0x1c>
  d2:	8082                	ret

000000d4 <__umodsi3>:
  d4:	8286                	mv	t0,ra
  d6:	3fc9                	jal	a8 <__hidden___udivsi3>
  d8:	852e                	mv	a0,a1
  da:	8282                	jr	t0
  dc:	40a00533          	neg	a0,a0
  e0:	00b04763          	bgtz	a1,ee <__umodsi3+0x1a>
  e4:	40b005b3          	neg	a1,a1
  e8:	b7c1                	j	a8 <__hidden___udivsi3>
  ea:	40b005b3          	neg	a1,a1
  ee:	8286                	mv	t0,ra
  f0:	3f65                	jal	a8 <__hidden___udivsi3>
  f2:	40a00533          	neg	a0,a0
  f6:	8282                	jr	t0

000000f8 <__modsi3>:
  f8:	8286                	mv	t0,ra
  fa:	0005c763          	bltz	a1,108 <__modsi3+0x10>
  fe:	00054963          	bltz	a0,110 <__modsi3+0x18>
 102:	375d                	jal	a8 <__hidden___udivsi3>
 104:	852e                	mv	a0,a1
 106:	8282                	jr	t0
 108:	40b005b3          	neg	a1,a1
 10c:	fe055be3          	bgez	a0,102 <__modsi3+0xa>
 110:	40a00533          	neg	a0,a0
 114:	3f51                	jal	a8 <__hidden___udivsi3>
 116:	40b00533          	neg	a0,a1
 11a:	8282                	jr	t0
	...

0000011e <mini_pad>:
	if(pad_to == 0) pad_to = len;
 11e:	c699                	beqz	a3,12c <mini_pad+0xe>
	int overflow = 0;
 120:	4301                	li	t1,0
	if(len > pad_to) {
 122:	00b6d763          	bge	a3,a1,130 <mini_pad+0x12>
		len = pad_to;
 126:	85b6                	mv	a1,a3
		overflow = 1;
 128:	4305                	li	t1,1
 12a:	a019                	j	130 <mini_pad+0x12>
	int overflow = 0;
 12c:	4301                	li	t1,0
	if(pad_to == 0) pad_to = len;
 12e:	86ae                	mv	a3,a1
	for(i = pad_to - len; i > 0; i --) {
 130:	8e8d                	sub	a3,a3,a1
	char * pbuffer = buffer;
 132:	87ba                	mv	a5,a4
 134:	00e683b3          	add	t2,a3,a4
	for(i = pad_to - len; i > 0; i --) {
 138:	40f382b3          	sub	t0,t2,a5
 13c:	04504a63          	bgtz	t0,190 <mini_pad+0x72>
 140:	fff6c793          	not	a5,a3
 144:	87fd                	srai	a5,a5,0x1f
 146:	8efd                	and	a3,a3,a5
 148:	96ba                	add	a3,a3,a4
 14a:	4781                	li	a5,0
	for(i = len; i > 0; i --) {
 14c:	40f58633          	sub	a2,a1,a5
 150:	00f682b3          	add	t0,a3,a5
 154:	04c04263          	bgtz	a2,198 <mini_pad+0x7a>
 158:	fff5c793          	not	a5,a1
 15c:	87fd                	srai	a5,a5,0x1f
 15e:	8dfd                	and	a1,a1,a5
 160:	95b6                	add	a1,a1,a3
	len = pbuffer - buffer;
 162:	40e58533          	sub	a0,a1,a4
	if(overflow) {
 166:	02030463          	beqz	t1,18e <mini_pad+0x70>
		for (i = 0; i < 3 && pbuffer > buffer; i ++) {
 16a:	02b77263          	bgeu	a4,a1,18e <mini_pad+0x70>
			*(pbuffer-- - 1) = '*';
 16e:	02a00793          	li	a5,42
 172:	fef58fa3          	sb	a5,-1(a1)
 176:	fff58693          	addi	a3,a1,-1
		for (i = 0; i < 3 && pbuffer > buffer; i ++) {
 17a:	00d77a63          	bgeu	a4,a3,18e <mini_pad+0x70>
			*(pbuffer-- - 1) = '*';
 17e:	fef58f23          	sb	a5,-2(a1)
 182:	ffe58693          	addi	a3,a1,-2
		for (i = 0; i < 3 && pbuffer > buffer; i ++) {
 186:	00d77463          	bgeu	a4,a3,18e <mini_pad+0x70>
			*(pbuffer-- - 1) = '*';
 18a:	fef58ea3          	sb	a5,-3(a1)
}
 18e:	8082                	ret
		*(pbuffer++) = pad_char;
 190:	0785                	addi	a5,a5,1
 192:	fec78fa3          	sb	a2,-1(a5)
	for(i = pad_to - len; i > 0; i --) {
 196:	b74d                	j	138 <mini_pad+0x1a>
		*(pbuffer++) = *(ptr++);
 198:	00f50633          	add	a2,a0,a5
 19c:	00064603          	lbu	a2,0(a2)
 1a0:	0785                	addi	a5,a5,1
 1a2:	00c28023          	sb	a2,0(t0)
	for(i = len; i > 0; i --) {
 1a6:	b75d                	j	14c <mini_pad+0x2e>

000001a8 <_puts>:
{
 1a8:	832a                	mv	t1,a0
 1aa:	852e                	mv	a0,a1
	if(!buf) return len;
 1ac:	ce01                	beqz	a2,1c4 <_puts+0x1c>
	char * p0 = b->buffer;
 1ae:	00062283          	lw	t0,0(a2)
	for (i = 0; i < len; i++) {
 1b2:	4701                	li	a4,0
		if(b->pbuffer == b->buffer + b->buffer_len - 1) {
 1b4:	425c                	lw	a5,4(a2)
	for (i = 0; i < len; i++) {
 1b6:	00a74863          	blt	a4,a0,1c6 <_puts+0x1e>
	*(b->pbuffer) = 0;
 1ba:	00078023          	sb	zero,0(a5)
	return b->pbuffer - p0;
 1be:	4248                	lw	a0,4(a2)
 1c0:	40550533          	sub	a0,a0,t0
}
 1c4:	8082                	ret
		if(b->pbuffer == b->buffer + b->buffer_len - 1) {
 1c6:	460c                	lw	a1,8(a2)
 1c8:	4214                	lw	a3,0(a2)
 1ca:	15fd                	addi	a1,a1,-1
 1cc:	96ae                	add	a3,a3,a1
 1ce:	fed786e3          	beq	a5,a3,1ba <_puts+0x12>
		*(b->pbuffer ++) = s[i];
 1d2:	00178693          	addi	a3,a5,1
 1d6:	c254                	sw	a3,4(a2)
 1d8:	00e306b3          	add	a3,t1,a4
 1dc:	0006c683          	lbu	a3,0(a3)
	for (i = 0; i < len; i++) {
 1e0:	0705                	addi	a4,a4,1
		*(b->pbuffer ++) = s[i];
 1e2:	00d78023          	sb	a3,0(a5)
	for (i = 0; i < len; i++) {
 1e6:	b7f9                	j	1b4 <_puts+0xc>

000001e8 <PrintHex>:
	while( (*DMDATA0) & 0x80 );
 1e8:	e00007b7          	lui	a5,0xe0000
 1ec:	0f478793          	addi	a5,a5,244 # e00000f4 <_eusrstack+0xbffff8f4>
 1f0:	4398                	lw	a4,0(a5)
 1f2:	08077713          	andi	a4,a4,128
 1f6:	ff6d                	bnez	a4,1f0 <PrintHex+0x8>
	*DMDATA0 = 0x78302088; //" 0x"
 1f8:	78302737          	lui	a4,0x78302
 1fc:	08870713          	addi	a4,a4,136 # 78302088 <_eusrstack+0x58301888>
		while( (*DMDATA0) & 0x80 );
 200:	e00006b7          	lui	a3,0xe0000
	*DMDATA0 = 0x78302088; //" 0x"
 204:	c398                	sw	a4,0(a5)
		while( (*DMDATA0) & 0x80 );
 206:	0f468693          	addi	a3,a3,244 # e00000f4 <_eusrstack+0xbffff8f4>
	for( shift = 28; shift >= 0; shift -= 4 )
 20a:	4771                	li	a4,28
		s += ( s < 10 ) ? '0' : ('a' - 10);
 20c:	45a5                	li	a1,9
	for( shift = 28; shift >= 0; shift -= 4 )
 20e:	5671                	li	a2,-4
		while( (*DMDATA0) & 0x80 );
 210:	429c                	lw	a5,0(a3)
 212:	0807f793          	andi	a5,a5,128
 216:	ffed                	bnez	a5,210 <PrintHex+0x28>
		int s = (n>>shift) & 0xf;
 218:	00e55333          	srl	t1,a0,a4
 21c:	00f37313          	andi	t1,t1,15
		s += ( s < 10 ) ? '0' : ('a' - 10);
 220:	0065b7b3          	sltu	a5,a1,t1
 224:	40f007b3          	neg	a5,a5
 228:	0277f793          	andi	a5,a5,39
 22c:	03078793          	addi	a5,a5,48
 230:	979a                	add	a5,a5,t1
		*DMDATA0 = 0x85 | (s<<8); //" 0x"
 232:	07a2                	slli	a5,a5,0x8
 234:	0857e793          	ori	a5,a5,133
 238:	c29c                	sw	a5,0(a3)
	for( shift = 28; shift >= 0; shift -= 4 )
 23a:	1771                	addi	a4,a4,-4
 23c:	fcc71ae3          	bne	a4,a2,210 <PrintHex+0x28>
}
 240:	8082                	ret

00000242 <mini_itoa.part.0>:
int mini_itoa(long value, unsigned int radix, int uppercase, int unsig, char *buffer)
 242:	1101                	addi	sp,sp,-32
 244:	ce06                	sw	ra,28(sp)
 246:	cc22                	sw	s0,24(sp)
 248:	ca26                	sw	s1,20(sp)
	int	negative = 0;
 24a:	c002                	sw	zero,0(sp)
int mini_itoa(long value, unsigned int radix, int uppercase, int unsig, char *buffer)
 24c:	832a                	mv	t1,a0
	if (value < 0 && !unsig) {
 24e:	00055763          	bgez	a0,25c <mini_itoa.part.0+0x1a>
 252:	e689                	bnez	a3,25c <mini_itoa.part.0+0x1a>
		negative = 1;
 254:	4785                	li	a5,1
		value = -value;
 256:	40a00333          	neg	t1,a0
		negative = 1;
 25a:	c03e                	sw	a5,0(sp)
 25c:	8a05                	andi	a2,a2,1
 25e:	06100413          	li	s0,97
 262:	c219                	beqz	a2,268 <mini_itoa.part.0+0x26>
 264:	04100413          	li	s0,65
	int	negative = 0;
 268:	84ba                	mv	s1,a4
		*(pbuffer++) = (digit < 10 ? '0' + digit : (uppercase ? 'A' : 'a') + digit - 10);
 26a:	1459                	addi	s0,s0,-10
		int digit = value % radix;
 26c:	851a                	mv	a0,t1
 26e:	c83a                	sw	a4,16(sp)
 270:	c21a                	sw	t1,4(sp)
 272:	c62e                	sw	a1,12(sp)
 274:	c41a                	sw	t1,8(sp)
 276:	3db9                	jal	d4 <__umodsi3>
		*(pbuffer++) = (digit < 10 ? '0' + digit : (uppercase ? 'A' : 'a') + digit - 10);
 278:	47a5                	li	a5,9
 27a:	4322                	lw	t1,8(sp)
 27c:	45b2                	lw	a1,12(sp)
 27e:	4742                	lw	a4,16(sp)
 280:	0ff57693          	zext.b	a3,a0
 284:	06a7e163          	bltu	a5,a0,2e6 <mini_itoa.part.0+0xa4>
 288:	03068693          	addi	a3,a3,48
 28c:	0ff6f693          	zext.b	a3,a3
 290:	00148793          	addi	a5,s1,1
 294:	00d48023          	sb	a3,0(s1)
		value /= radix;
 298:	851a                	mv	a0,t1
 29a:	c83a                	sw	a4,16(sp)
		*(pbuffer++) = (digit < 10 ? '0' + digit : (uppercase ? 'A' : 'a') + digit - 10);
 29c:	c63e                	sw	a5,12(sp)
		value /= radix;
 29e:	c42e                	sw	a1,8(sp)
 2a0:	3521                	jal	a8 <__hidden___udivsi3>
	} while (value > 0);
 2a2:	4692                	lw	a3,4(sp)
 2a4:	45a2                	lw	a1,8(sp)
 2a6:	47b2                	lw	a5,12(sp)
 2a8:	4742                	lw	a4,16(sp)
		value /= radix;
 2aa:	832a                	mv	t1,a0
	} while (value > 0);
 2ac:	02b6fb63          	bgeu	a3,a1,2e2 <mini_itoa.part.0+0xa0>
	if (negative)
 2b0:	4682                	lw	a3,0(sp)
 2b2:	c699                	beqz	a3,2c0 <mini_itoa.part.0+0x7e>
		*(pbuffer++) = '-';
 2b4:	02d00693          	li	a3,45
 2b8:	00d78023          	sb	a3,0(a5)
 2bc:	00248793          	addi	a5,s1,2
	len = (pbuffer - buffer);
 2c0:	40e78533          	sub	a0,a5,a4
	for (i = 0; i < len / 2; i++) {
 2c4:	01f55693          	srli	a3,a0,0x1f
 2c8:	96aa                	add	a3,a3,a0
	*(pbuffer) = '\0';
 2ca:	00078023          	sb	zero,0(a5)
	for (i = 0; i < len / 2; i++) {
 2ce:	8685                	srai	a3,a3,0x1
 2d0:	4601                	li	a2,0
 2d2:	17fd                	addi	a5,a5,-1
 2d4:	00d64b63          	blt	a2,a3,2ea <mini_itoa.part.0+0xa8>
}
 2d8:	40f2                	lw	ra,28(sp)
 2da:	4462                	lw	s0,24(sp)
 2dc:	44d2                	lw	s1,20(sp)
 2de:	6105                	addi	sp,sp,32
 2e0:	8082                	ret
		*(pbuffer++) = (digit < 10 ? '0' + digit : (uppercase ? 'A' : 'a') + digit - 10);
 2e2:	84be                	mv	s1,a5
 2e4:	b761                	j	26c <mini_itoa.part.0+0x2a>
 2e6:	96a2                	add	a3,a3,s0
 2e8:	b755                	j	28c <mini_itoa.part.0+0x4a>
		char j = buffer[i];
 2ea:	00c705b3          	add	a1,a4,a2
		buffer[i] = buffer[len-i-1];
 2ee:	0007c283          	lbu	t0,0(a5)
		char j = buffer[i];
 2f2:	0005c303          	lbu	t1,0(a1)
	for (i = 0; i < len / 2; i++) {
 2f6:	0605                	addi	a2,a2,1
		buffer[i] = buffer[len-i-1];
 2f8:	00558023          	sb	t0,0(a1)
		buffer[len-i-1] = j;
 2fc:	00678023          	sb	t1,0(a5)
	for (i = 0; i < len / 2; i++) {
 300:	bfc9                	j	2d2 <mini_itoa.part.0+0x90>

00000302 <gpio_set_mode>:
	
	// Make array of uint8_t from [pin] enum. See definition for details
	uint8_t *byte = (uint8_t *)&pin;
	
	// Set the RCC Register to enable clock on the specified port
	GPIO_RCC->APB2PCENR |= (RCC_APB2PCENR_AFIO | (RCC_APB2PCENR_IOPxEN << byte[0]));
 302:	400216b7          	lui	a3,0x40021
 306:	4e90                	lw	a2,24(a3)
 308:	4791                	li	a5,4
 30a:	00a797b3          	sll	a5,a5,a0
 30e:	8fd1                	or	a5,a5,a2
 310:	0017e793          	ori	a5,a5,1
 314:	ce9c                	sw	a5,24(a3)
 316:	0ff57713          	zext.b	a4,a0

	// Clear then set the GPIO Config Register
	GPIO_PORT_MAP[ byte[0] ]->CFGLR &=        ~(0x0F  << (4 * byte[1]));
 31a:	6785                	lui	a5,0x1
 31c:	070a                	slli	a4,a4,0x2
 31e:	94478793          	addi	a5,a5,-1724 # 944 <GPIO_PORT_MAP>
 322:	97ba                	add	a5,a5,a4
 324:	4398                	lw	a4,0(a5)
 326:	8119                	srli	a0,a0,0x6
 328:	3fc57513          	andi	a0,a0,1020
 32c:	4314                	lw	a3,0(a4)
 32e:	47bd                	li	a5,15
 330:	00a797b3          	sll	a5,a5,a0
 334:	fff7c793          	not	a5,a5
 338:	8ff5                	and	a5,a5,a3
 33a:	c31c                	sw	a5,0(a4)
	GPIO_PORT_MAP[ byte[0] ]->CFGLR |=  (mode & 0x0F) << (4 * byte[1]);
 33c:	431c                	lw	a5,0(a4)
 33e:	00a595b3          	sll	a1,a1,a0
 342:	8ddd                	or	a1,a1,a5
 344:	c30c                	sw	a1,0(a4)

	// If [mode] is INPUT_PULLUP or INPUT_PULLDOWN, set the [OUTDR] Register
	if(mode == INPUT_PULLUP || mode == INPUT_PULLDOWN)
		gpio_digital_write(pin, mode >> 4);
}
 346:	8082                	ret

00000348 <internal_handle_input.constprop.0>:
void handle_debug_input( int numbytes, uint8_t * data ) __attribute__((weak));
void handle_debug_input( int numbytes, uint8_t * data ) { (void)numbytes; (void)data; }

static void internal_handle_input( volatile uint32_t * dmdata0 )
{
	uint32_t dmd0 = *dmdata0;
 348:	e00007b7          	lui	a5,0xe0000
 34c:	0f47a783          	lw	a5,244(a5) # e00000f4 <_eusrstack+0xbffff8f4>
	int bytes = (dmd0 & 0x3f) - 4;
	if( bytes > 0 && bytes < 16 )
	{
		handle_debug_input( bytes, ((uint8_t*)dmdata0) + 1 );
	}
}
 350:	8082                	ret

00000352 <_write.constprop.0>:
//     status word = 0xcx = timed out.
// declare as weak to allow overriding.
WEAK int _write(int fd, const char *buf, int size)
{
	(void)fd;
	if( ( *DMDATA0 & 0xc0 ) == 0xc0 ) return 0;
 352:	e00007b7          	lui	a5,0xe0000
 356:	0f478793          	addi	a5,a5,244 # e00000f4 <_eusrstack+0xbffff8f4>
 35a:	4398                	lw	a4,0(a5)
WEAK int _write(int fd, const char *buf, int size)
 35c:	1121                	addi	sp,sp,-24
 35e:	ca06                	sw	ra,20(sp)
 360:	c822                	sw	s0,16(sp)
 362:	c626                	sw	s1,12(sp)
	if( ( *DMDATA0 & 0xc0 ) == 0xc0 ) return 0;
 364:	0c077713          	andi	a4,a4,192
 368:	0c000693          	li	a3,192
 36c:	00d70b63          	beq	a4,a3,382 <_write.constprop.0+0x30>

	char buffer[4] = { 0 };
 370:	c402                	sw	zero,8(sp)
 372:	842e                	mv	s0,a1
	int place = 0;
	uint32_t lastdmd;
	uint32_t timeout = FUNCONF_DEBUGPRINTF_TIMEOUT; // Give up after ~120ms

	if( size == 0 )
 374:	eddd                	bnez	a1,432 <_write.constprop.0+0xe0>
	{
		lastdmd = (*DMDATA0);
 376:	439c                	lw	a5,0(a5)
		if( lastdmd && !(lastdmd&0x80) ) internal_handle_input( (uint32_t*)DMDATA0 );
 378:	c789                	beqz	a5,382 <_write.constprop.0+0x30>
 37a:	0807f793          	andi	a5,a5,128
 37e:	e391                	bnez	a5,382 <_write.constprop.0+0x30>
 380:	37e1                	jal	348 <internal_handle_input.constprop.0>
	if( ( *DMDATA0 & 0xc0 ) == 0xc0 ) return 0;
 382:	4401                	li	s0,0

		//buf += tosend;
		place += tosend;
	}
	return size;
}
 384:	40d2                	lw	ra,20(sp)
 386:	8522                	mv	a0,s0
 388:	4442                	lw	s0,16(sp)
 38a:	44b2                	lw	s1,12(sp)
 38c:	0161                	addi	sp,sp,24
 38e:	8082                	ret
		int tosend = size - place;
 390:	409407b3          	sub	a5,s0,s1
		if( tosend > 7 ) tosend = 7;
 394:	471d                	li	a4,7
 396:	00f75363          	bge	a4,a5,39c <_write.constprop.0+0x4a>
 39a:	87ba                	mv	a5,a4
 39c:	001006b7          	lui	a3,0x100
		while( ( lastdmd = (*DMDATA0) ) & 0x80 )
 3a0:	e0000737          	lui	a4,0xe0000
		if( tosend > 7 ) tosend = 7;
 3a4:	0685                	addi	a3,a3,1 # 100001 <lib_gpioctrl.c.9b7c6186+0xfd1a1>
		while( ( lastdmd = (*DMDATA0) ) & 0x80 )
 3a6:	0f470713          	addi	a4,a4,244 # e00000f4 <_eusrstack+0xbffff8f4>
 3aa:	4310                	lw	a2,0(a4)
 3ac:	08067593          	andi	a1,a2,128
 3b0:	e1a5                	bnez	a1,410 <_write.constprop.0+0xbe>
		if( lastdmd ) internal_handle_input( (uint32_t*)DMDATA0 );
 3b2:	c611                	beqz	a2,3be <_write.constprop.0+0x6c>
 3b4:	c22a                	sw	a0,4(sp)
 3b6:	c03e                	sw	a5,0(sp)
 3b8:	3f41                	jal	348 <internal_handle_input.constprop.0>
 3ba:	4512                	lw	a0,4(sp)
 3bc:	4782                	lw	a5,0(sp)
 3be:	0034                	addi	a3,sp,8
		if( tosend > 7 ) tosend = 7;
 3c0:	470d                	li	a4,3
 3c2:	85b6                	mv	a1,a3
		while( t < tosend )
 3c4:	04f74d63          	blt	a4,a5,41e <_write.constprop.0+0xcc>
		*DMDATA1 = *(uint32_t*)&(buffer[0]);
 3c8:	46a2                	lw	a3,8(sp)
 3ca:	e0000737          	lui	a4,0xe0000
		while( t < tosend && t < 3 )
 3ce:	460d                	li	a2,3
		*DMDATA1 = *(uint32_t*)&(buffer[0]);
 3d0:	0ed72c23          	sw	a3,248(a4) # e00000f8 <_eusrstack+0xbffff8f8>
 3d4:	009506b3          	add	a3,a0,s1
		t = 0;
 3d8:	4701                	li	a4,0
			buffer[t+1] = buf[t+place];
 3da:	0006c283          	lbu	t0,0(a3)
 3de:	0705                	addi	a4,a4,1
 3e0:	00e58333          	add	t1,a1,a4
 3e4:	00530023          	sb	t0,0(t1)
		while( t < tosend && t < 3 )
 3e8:	00e78563          	beq	a5,a4,3f2 <_write.constprop.0+0xa0>
 3ec:	0685                	addi	a3,a3,1
 3ee:	fec716e3          	bne	a4,a2,3da <_write.constprop.0+0x88>
		buffer[0] = 0x80 | (tosend + 4);
 3f2:	00478713          	addi	a4,a5,4
 3f6:	f8076713          	ori	a4,a4,-128
 3fa:	00e10423          	sb	a4,8(sp)
		*DMDATA0 = *(uint32_t*)&(buffer[0]);
 3fe:	46a2                	lw	a3,8(sp)
 400:	e0000737          	lui	a4,0xe0000
		place += tosend;
 404:	94be                	add	s1,s1,a5
		*DMDATA0 = *(uint32_t*)&(buffer[0]);
 406:	0ed72a23          	sw	a3,244(a4) # e00000f4 <_eusrstack+0xbffff8f4>
	while( place < size )
 40a:	f884c3e3          	blt	s1,s0,390 <_write.constprop.0+0x3e>
 40e:	bf9d                	j	384 <_write.constprop.0+0x32>
			if( timeout-- == 0 )
 410:	16fd                	addi	a3,a3,-1
 412:	fec1                	bnez	a3,3aa <_write.constprop.0+0x58>
				*DMDATA0 |= 0xc0;
 414:	431c                	lw	a5,0(a4)
 416:	0c07e793          	ori	a5,a5,192
 41a:	c31c                	sw	a5,0(a4)
				return 0;
 41c:	b79d                	j	382 <_write.constprop.0+0x30>
			buffer[t-3] = buf[t+place];
 41e:	00e48633          	add	a2,s1,a4
 422:	962a                	add	a2,a2,a0
 424:	00064603          	lbu	a2,0(a2)
			t++;
 428:	0705                	addi	a4,a4,1
 42a:	0685                	addi	a3,a3,1
			buffer[t-3] = buf[t+place];
 42c:	fec68fa3          	sb	a2,-1(a3)
 430:	bf51                	j	3c4 <_write.constprop.0+0x72>
 432:	4481                	li	s1,0
 434:	bfd9                	j	40a <_write.constprop.0+0xb8>

00000436 <__puts_uart>:
{
 436:	1161                	addi	sp,sp,-8
 438:	c022                	sw	s0,0(sp)
 43a:	c206                	sw	ra,4(sp)
 43c:	842e                	mv	s0,a1
	_write( 0, s, len );
 43e:	3f11                	jal	352 <_write.constprop.0>
}
 440:	4092                	lw	ra,4(sp)
 442:	8522                	mv	a0,s0
 444:	4402                	lw	s0,0(sp)
 446:	0121                	addi	sp,sp,8
 448:	8082                	ret

0000044a <handle_reset>:
	asm volatile( "\n\
 44a:	20000197          	auipc	gp,0x20000
 44e:	fb218193          	addi	gp,gp,-78 # 200003fc <__global_pointer$>
 452:	40418113          	addi	sp,gp,1028 # 20000800 <_eusrstack>
 456:	6509                	lui	a0,0x2
 458:	88050513          	addi	a0,a0,-1920 # 1880 <ch32fun.c.e1d0904f+0x701>
 45c:	30051073          	csrw	mstatus,a0
 460:	468d                	li	a3,3
 462:	00000517          	auipc	a0,0x0
 466:	b9e50513          	addi	a0,a0,-1122 # 0 <InterruptVector>
 46a:	8d55                	or	a0,a0,a3
 46c:	30551073          	csrw	mtvec,a0
asm volatile(
 470:	c0418513          	addi	a0,gp,-1020 # 20000000 <g_systick_millis>
 474:	c0818593          	addi	a1,gp,-1016 # 20000004 <_ebss>
 478:	4601                	li	a2,0
 47a:	00b55663          	bge	a0,a1,486 <handle_reset+0x3c>
 47e:	c110                	sw	a2,0(a0)
 480:	0511                	addi	a0,a0,4
 482:	feb54ee3          	blt	a0,a1,47e <handle_reset+0x34>
 486:	00000517          	auipc	a0,0x0
 48a:	4ce50513          	addi	a0,a0,1230 # 954 <_data_lma>
 48e:	c0418593          	addi	a1,gp,-1020 # 20000000 <g_systick_millis>
 492:	c0418613          	addi	a2,gp,-1020 # 20000000 <g_systick_millis>
 496:	00c58863          	beq	a1,a2,4a6 <handle_reset+0x5c>
 49a:	4114                	lw	a3,0(a0)
 49c:	c194                	sw	a3,0(a1)
 49e:	0511                	addi	a0,a0,4
 4a0:	0591                	addi	a1,a1,4
 4a2:	fec59ae3          	bne	a1,a2,496 <handle_reset+0x4c>
	SysTick->CTLR = 5;
 4a6:	e000f7b7          	lui	a5,0xe000f
 4aa:	4715                	li	a4,5
 4ac:	c398                	sw	a4,0(a5)
asm volatile(
 4ae:	75800793          	li	a5,1880
 4b2:	34179073          	csrw	mepc,a5
 4b6:	30200073          	mret

000004ba <ADC1_2_IRQHandler>:

// Return the Machine Exception Program Register (MEPC)
static inline uint32_t __get_MEPC(void)
{
	uint32_t result;
	__ASM volatile( ADD_ARCH_ZICSR "csrr %0," "mepc" : "=r"(result));
 4ba:	34102573          	csrr	a0,mepc
	PrintHex( __get_MEPC() ); // "addr2line -e debugprintfdemo.elf 0x000007e6" ---> debugprintfdemo.c:45
 4be:	332d                	jal	1e8 <PrintHex>
	__ASM volatile( ADD_ARCH_ZICSR "csrr %0, mstatus": "=r"(result) );
 4c0:	30002573          	csrr	a0,mstatus
	PrintHex( __get_MSTATUS() );
 4c4:	3315                	jal	1e8 <PrintHex>

// Return the Machine Trap Value Register (MTVAL)
static inline uint32_t __get_MTVAL(void)
{
	uint32_t result;
	__ASM volatile( ADD_ARCH_ZICSR "csrr %0," "mtval" : "=r" (result) );
 4c6:	34302573          	csrr	a0,mtval
	PrintHex( __get_MTVAL() );
 4ca:	3b39                	jal	1e8 <PrintHex>
	__ASM volatile( ADD_ARCH_ZICSR "csrr %0," "mcause": "=r"(result));
 4cc:	34202573          	csrr	a0,mcause
	PrintHex( __get_MCAUSE() );
 4d0:	3b21                	jal	1e8 <PrintHex>
	while( (*DMDATA0) & 0x80 );
 4d2:	e00007b7          	lui	a5,0xe0000
 4d6:	0f478793          	addi	a5,a5,244 # e00000f4 <_eusrstack+0xbffff8f4>
 4da:	4398                	lw	a4,0(a5)
 4dc:	08077713          	andi	a4,a4,128
 4e0:	ff6d                	bnez	a4,4da <ADC1_2_IRQHandler+0x20>
	*DMDATA0 = 0x0a85;
 4e2:	6705                	lui	a4,0x1
 4e4:	a8570713          	addi	a4,a4,-1403 # a85 <_data_lma+0x131>
 4e8:	c398                	sw	a4,0(a5)
	while( (*DMDATA0) & 0x80 );
 4ea:	e00007b7          	lui	a5,0xe0000
 4ee:	0f478793          	addi	a5,a5,244 # e00000f4 <_eusrstack+0xbffff8f4>
 4f2:	4398                	lw	a4,0(a5)
 4f4:	08077713          	andi	a4,a4,128
 4f8:	ff6d                	bnez	a4,4f2 <ADC1_2_IRQHandler+0x38>
	*DMDATA0 = 0xaaaaaa83;
 4fa:	aaaab737          	lui	a4,0xaaaab
 4fe:	a8370713          	addi	a4,a4,-1405 # aaaaaa83 <_eusrstack+0x8aaaa283>
 502:	c398                	sw	a4,0(a5)
	asm volatile( "1: j 1b" );
 504:	a001                	j	504 <ADC1_2_IRQHandler+0x4a>

00000506 <NMI_Handler>:
	RCC->INTR |= RCC_CSSC;	// clear the clock security int flag
 506:	40021737          	lui	a4,0x40021
 50a:	471c                	lw	a5,8(a4)
 50c:	008006b7          	lui	a3,0x800
 510:	8fd5                	or	a5,a5,a3
 512:	c71c                	sw	a5,8(a4)

00000514 <strlen>:
	for (; *s; s++);
 514:	87aa                	mv	a5,a0
 516:	0007c703          	lbu	a4,0(a5)
 51a:	e701                	bnez	a4,522 <strlen+0xe>
}
 51c:	40a78533          	sub	a0,a5,a0
 520:	8082                	ret
	for (; *s; s++);
 522:	0785                	addi	a5,a5,1
 524:	bfcd                	j	516 <strlen+0x2>

00000526 <mini_vpprintf>:
{
 526:	fa410113          	addi	sp,sp,-92
 52a:	caa2                	sw	s0,84(sp)
 52c:	c8a6                	sw	s1,80(sp)
 52e:	cc86                	sw	ra,88(sp)
 530:	c02a                	sw	a0,0(sp)
 532:	c22e                	sw	a1,4(sp)
 534:	8432                	mv	s0,a2
 536:	84b6                	mv	s1,a3
	if(puts == (void*)0) {
 538:	e509                	bnez	a0,542 <mini_vpprintf+0x1c>
		puts = _puts; buf = (void*)0;
 53a:	1a800793          	li	a5,424
 53e:	c202                	sw	zero,4(sp)
 540:	c03e                	sw	a5,0(sp)
	int n = 0;
 542:	ca02                	sw	zero,20(sp)
	while ((ch=*(fmt++))) {
 544:	00044783          	lbu	a5,0(s0)
 548:	00140713          	addi	a4,s0,1
 54c:	00f10fa3          	sb	a5,31(sp)
 550:	eb81                	bnez	a5,560 <mini_vpprintf+0x3a>
}
 552:	40e6                	lw	ra,88(sp)
 554:	4456                	lw	s0,84(sp)
 556:	4552                	lw	a0,20(sp)
 558:	44c6                	lw	s1,80(sp)
 55a:	05c10113          	addi	sp,sp,92
 55e:	8082                	ret
 560:	c63a                	sw	a4,12(sp)
		if (ch!='%') {
 562:	02500693          	li	a3,37
 566:	02d78063          	beq	a5,a3,586 <mini_vpprintf+0x60>
			len = puts(&ch, len, buf);
 56a:	4612                	lw	a2,4(sp)
 56c:	4782                	lw	a5,0(sp)
 56e:	4585                	li	a1,1
 570:	01f10513          	addi	a0,sp,31
 574:	9782                	jalr	a5
	while ((ch=*(fmt++))) {
 576:	4732                	lw	a4,12(sp)
 578:	c426                	sw	s1,8(sp)
 57a:	843a                	mv	s0,a4
		n = n + len;
 57c:	47d2                	lw	a5,20(sp)
 57e:	44a2                	lw	s1,8(sp)
 580:	97aa                	add	a5,a5,a0
 582:	ca3e                	sw	a5,20(sp)
 584:	b7c1                	j	544 <mini_vpprintf+0x1e>
			ch=*(fmt++);
 586:	00144783          	lbu	a5,1(s0)
			if (ch == '0') pad_char = '0';
 58a:	03000693          	li	a3,48
			ch=*(fmt++);
 58e:	00240713          	addi	a4,s0,2
 592:	00f10fa3          	sb	a5,31(sp)
			if (ch == '0') pad_char = '0';
 596:	c63e                	sw	a5,12(sp)
 598:	08d79363          	bne	a5,a3,61e <mini_vpprintf+0xf8>
				ch=*(fmt++);
 59c:	843a                	mv	s0,a4
 59e:	4681                	li	a3,0
 5a0:	4701                	li	a4,0
			while (ch >= '0' && ch <= '9') {
 5a2:	45a5                	li	a1,9
 5a4:	a819                	j	5ba <mini_vpprintf+0x94>
				pad_to = pad_to * 10 + (ch - '0');
 5a6:	00271793          	slli	a5,a4,0x2
 5aa:	97ba                	add	a5,a5,a4
 5ac:	0786                	slli	a5,a5,0x1
				ch=*(fmt++);
 5ae:	0405                	addi	s0,s0,1
				pad_to = pad_to * 10 + (ch - '0');
 5b0:	00f60733          	add	a4,a2,a5
				ch=*(fmt++);
 5b4:	fff44783          	lbu	a5,-1(s0)
 5b8:	4685                	li	a3,1
			while (ch >= '0' && ch <= '9') {
 5ba:	fd078613          	addi	a2,a5,-48
 5be:	0ff67513          	zext.b	a0,a2
 5c2:	fea5f2e3          	bgeu	a1,a0,5a6 <mini_vpprintf+0x80>
 5c6:	c299                	beqz	a3,5cc <mini_vpprintf+0xa6>
 5c8:	00f10fa3          	sb	a5,31(sp)
			if(pad_to > (signed int) sizeof(bf)) {
 5cc:	c83a                	sw	a4,16(sp)
 5ce:	46e1                	li	a3,24
 5d0:	00e6d363          	bge	a3,a4,5d6 <mini_vpprintf+0xb0>
 5d4:	c836                	sw	a3,16(sp)
			if (ch == 'l') {
 5d6:	06c00613          	li	a2,108
			char l = 0;
 5da:	4681                	li	a3,0
			if (ch == 'l') {
 5dc:	00c79863          	bne	a5,a2,5ec <mini_vpprintf+0xc6>
				ch=*(fmt++);
 5e0:	00044783          	lbu	a5,0(s0)
				l = 1;
 5e4:	4685                	li	a3,1
				ch=*(fmt++);
 5e6:	0405                	addi	s0,s0,1
 5e8:	00f10fa3          	sb	a5,31(sp)
			switch (ch) {
 5ec:	01f14603          	lbu	a2,31(sp)
 5f0:	06400793          	li	a5,100
 5f4:	06f60563          	beq	a2,a5,65e <mini_vpprintf+0x138>
 5f8:	02c7e763          	bltu	a5,a2,626 <mini_vpprintf+0x100>
 5fc:	05800793          	li	a5,88
 600:	0af60063          	beq	a2,a5,6a0 <mini_vpprintf+0x17a>
 604:	06300793          	li	a5,99
 608:	0af60d63          	beq	a2,a5,6c2 <mini_vpprintf+0x19c>
 60c:	d239                	beqz	a2,552 <mini_vpprintf+0x2c>
					len = puts(&ch, len, buf);
 60e:	4612                	lw	a2,4(sp)
 610:	4782                	lw	a5,0(sp)
 612:	4585                	li	a1,1
 614:	01f10513          	addi	a0,sp,31
 618:	9782                	jalr	a5
					break;
 61a:	c426                	sw	s1,8(sp)
 61c:	b785                	j	57c <mini_vpprintf+0x56>
			char pad_char = ' ';
 61e:	02000693          	li	a3,32
 622:	c636                	sw	a3,12(sp)
 624:	bfa5                	j	59c <mini_vpprintf+0x76>
			switch (ch) {
 626:	07500793          	li	a5,117
 62a:	02f60a63          	beq	a2,a5,65e <mini_vpprintf+0x138>
 62e:	07800793          	li	a5,120
 632:	06f60763          	beq	a2,a5,6a0 <mini_vpprintf+0x17a>
 636:	07300793          	li	a5,115
 63a:	fcf61ae3          	bne	a2,a5,60e <mini_vpprintf+0xe8>
					ptr = va_arg(va, char*);
 63e:	00448793          	addi	a5,s1,4
 642:	4084                	lw	s1,0(s1)
 644:	cc3a                	sw	a4,24(sp)
 646:	c43e                	sw	a5,8(sp)
					len = mini_strlen(ptr);
 648:	8526                	mv	a0,s1
 64a:	35e9                	jal	514 <strlen>
					if (pad_to > 0) {
 64c:	4762                	lw	a4,24(sp)
					len = mini_strlen(ptr);
 64e:	85aa                	mv	a1,a0
					if (pad_to > 0) {
 650:	08e05663          	blez	a4,6dc <mini_vpprintf+0x1b6>
						len = mini_pad(ptr, len, pad_char, pad_to, bf);
 654:	46c2                	lw	a3,16(sp)
 656:	4632                	lw	a2,12(sp)
 658:	1838                	addi	a4,sp,56
 65a:	8526                	mv	a0,s1
 65c:	a01d                	j	682 <mini_vpprintf+0x15c>
						len = mini_itoa(va_arg(va, unsigned long), 10, 0, (ch=='u'), bf2);
 65e:	00448793          	addi	a5,s1,4
 662:	c43e                	sw	a5,8(sp)
					if(l) {
 664:	c695                	beqz	a3,690 <mini_vpprintf+0x16a>
						len = mini_itoa(va_arg(va, unsigned long), 10, 0, (ch=='u'), bf2);
 666:	f8b60613          	addi	a2,a2,-117
 66a:	1018                	addi	a4,sp,32
 66c:	00163693          	seqz	a3,a2
 670:	4088                	lw	a0,0(s1)
 672:	4601                	li	a2,0
 674:	45a9                	li	a1,10
 676:	36f1                	jal	242 <mini_itoa.part.0>
					len = mini_pad(bf2, len, pad_char, pad_to, bf);
 678:	46c2                	lw	a3,16(sp)
 67a:	4632                	lw	a2,12(sp)
 67c:	1838                	addi	a4,sp,56
 67e:	85aa                	mv	a1,a0
					len = mini_pad(bf2, len, pad_char, pad_to, bf);
 680:	1008                	addi	a0,sp,32
 682:	3c71                	jal	11e <mini_pad>
					len = puts(bf, len, buf);
 684:	4612                	lw	a2,4(sp)
					len = mini_pad(bf2, len, pad_char, pad_to, bf);
 686:	85aa                	mv	a1,a0
					len = puts(bf, len, buf);
 688:	1828                	addi	a0,sp,56
 68a:	4782                	lw	a5,0(sp)
 68c:	9782                	jalr	a5
					break;
 68e:	b5fd                	j	57c <mini_vpprintf+0x56>
						if(ch == 'u') {
 690:	07500793          	li	a5,117
 694:	1018                	addi	a4,sp,32
 696:	4685                	li	a3,1
 698:	fcf60ce3          	beq	a2,a5,670 <mini_vpprintf+0x14a>
	if (radix > 16)
 69c:	4681                	li	a3,0
 69e:	bfc9                	j	670 <mini_vpprintf+0x14a>
					if(l) {
 6a0:	4088                	lw	a0,0(s1)
						len = mini_itoa(va_arg(va, unsigned long), 16, (ch=='X'), 1, bf2);
 6a2:	fa860613          	addi	a2,a2,-88
						len = mini_itoa(va_arg(va, unsigned long), 10, 0, (ch=='u'), bf2);
 6a6:	00448793          	addi	a5,s1,4
 6aa:	1018                	addi	a4,sp,32
 6ac:	4685                	li	a3,1
 6ae:	00163613          	seqz	a2,a2
 6b2:	45c1                	li	a1,16
 6b4:	c43e                	sw	a5,8(sp)
	if (radix > 16)
 6b6:	3671                	jal	242 <mini_itoa.part.0>
					len = mini_pad(bf2, len, pad_char, pad_to, bf);
 6b8:	46c2                	lw	a3,16(sp)
 6ba:	4632                	lw	a2,12(sp)
 6bc:	85aa                	mv	a1,a0
 6be:	1838                	addi	a4,sp,56
 6c0:	b7c1                	j	680 <mini_vpprintf+0x15a>
					ch = (char)(va_arg(va, int));
 6c2:	00448793          	addi	a5,s1,4
 6c6:	c43e                	sw	a5,8(sp)
 6c8:	409c                	lw	a5,0(s1)
					len = mini_pad(&ch, 1, pad_char, pad_to, bf);
 6ca:	46c2                	lw	a3,16(sp)
 6cc:	4632                	lw	a2,12(sp)
					ch = (char)(va_arg(va, int));
 6ce:	00f10fa3          	sb	a5,31(sp)
					len = mini_pad(&ch, 1, pad_char, pad_to, bf);
 6d2:	1838                	addi	a4,sp,56
 6d4:	4585                	li	a1,1
 6d6:	01f10513          	addi	a0,sp,31
 6da:	b765                	j	682 <mini_vpprintf+0x15c>
						len = puts(ptr, len, buf);
 6dc:	4612                	lw	a2,4(sp)
 6de:	8526                	mv	a0,s1
 6e0:	b76d                	j	68a <mini_vpprintf+0x164>

000006e2 <printf>:
{
 6e2:	1111                	addi	sp,sp,-28
 6e4:	c632                	sw	a2,12(sp)
	int ret_status = mini_vpprintf(__puts_uart, 0, format, args);
 6e6:	862a                	mv	a2,a0
{
 6e8:	c42e                	sw	a1,8(sp)
 6ea:	c836                	sw	a3,16(sp)
	int ret_status = mini_vpprintf(__puts_uart, 0, format, args);
 6ec:	4581                	li	a1,0
	va_start( args, format );
 6ee:	0034                	addi	a3,sp,8
	int ret_status = mini_vpprintf(__puts_uart, 0, format, args);
 6f0:	43600513          	li	a0,1078
{
 6f4:	c206                	sw	ra,4(sp)
 6f6:	ca3a                	sw	a4,20(sp)
 6f8:	cc3e                	sw	a5,24(sp)
	va_start( args, format );
 6fa:	c036                	sw	a3,0(sp)
	int ret_status = mini_vpprintf(__puts_uart, 0, format, args);
 6fc:	352d                	jal	526 <mini_vpprintf>
}
 6fe:	4092                	lw	ra,4(sp)
 700:	0171                	addi	sp,sp,28
 702:	8082                	ret

00000704 <SystemInit>:
	#endif
#elif defined(CH32X03x)
	FLASH->ACTLR = FLASH_ACTLR_LATENCY_2;                   // +2 Cycle Latency (Recommended per TRM)
#elif defined(CH32V003)
	#if FUNCONF_SYSTEM_CORE_CLOCK > 25000000
		FLASH->ACTLR = FLASH_ACTLR_LATENCY_1;               // +1 Cycle Latency
 704:	400227b7          	lui	a5,0x40022
 708:	4705                	li	a4,1
 70a:	c398                	sw	a4,0(a5)
#elif defined(FUNCONF_USE_HSI) && FUNCONF_USE_HSI
	#if defined(CH32V30x) || defined(CH32V20x) || defined(CH32V10x)
		EXTEN->EXTEN_CTR |= EXTEN_PLL_HSI_PRE;
	#endif
	#if defined(FUNCONF_USE_PLL) && FUNCONF_USE_PLL
		RCC->CFGR0 = BASE_CFGR0;
 70c:	400217b7          	lui	a5,0x40021
		RCC->CTLR  = BASE_CTLR | RCC_HSION | RCC_PLLON; 			// Use HSI, enable PLL.
 710:	01080737          	lui	a4,0x1080
		RCC->CFGR0 = BASE_CFGR0;
 714:	0007a223          	sw	zero,4(a5) # 40021004 <_eusrstack+0x20020804>
		RCC->CTLR  = BASE_CTLR | RCC_HSION | RCC_PLLON; 			// Use HSI, enable PLL.
 718:	08170713          	addi	a4,a4,129 # 1080081 <lib_gpioctrl.c.9b7c6186+0x107d221>
 71c:	c398                	sw	a4,0(a5)
		FLASH->ACTLR = FLASH_ACTLR_LATENCY_1;       		// +1 Cycle Latency
	#endif
#endif

#if !defined(CH57x) && !defined(CH58x) && !defined(CH59x)
	RCC->INTR  = 0x009F0000;                               // Clear PLL, CSSC, HSE, HSI and LSI ready flags.
 71e:	009f0737          	lui	a4,0x9f0
 722:	c798                	sw	a4,8(a5)
#endif

#if defined(FUNCONF_USE_PLL) && FUNCONF_USE_PLL && !defined(CH57x) && !defined(CH58x) && !defined(CH59x)
	while((RCC->CTLR & RCC_PLLRDY) == 0);                       	// Wait till PLL is ready
 724:	4398                	lw	a4,0(a5)
 726:	00671693          	slli	a3,a4,0x6
 72a:	fe06dde3          	bgez	a3,724 <SystemInit+0x20>
	uint32_t tmp32 = RCC->CFGR0 & ~(0x03);							// clr the SW
 72e:	43d8                	lw	a4,4(a5)
	RCC->CFGR0 = tmp32 | RCC_SW_PLL;                       			// Select PLL as system clock source
	while ((RCC->CFGR0 & (uint32_t)RCC_SWS) != (uint32_t)0x08); 	// Wait till PLL is used as system clock source
 730:	400216b7          	lui	a3,0x40021
	uint32_t tmp32 = RCC->CFGR0 & ~(0x03);							// clr the SW
 734:	9b71                	andi	a4,a4,-4
	RCC->CFGR0 = tmp32 | RCC_SW_PLL;                       			// Select PLL as system clock source
 736:	00276713          	ori	a4,a4,2
 73a:	c3d8                	sw	a4,4(a5)
	while ((RCC->CFGR0 & (uint32_t)RCC_SWS) != (uint32_t)0x08); 	// Wait till PLL is used as system clock source
 73c:	4721                	li	a4,8
 73e:	42dc                	lw	a5,4(a3)
 740:	8bb1                	andi	a5,a5,12
 742:	fee79ee3          	bne	a5,a4,73e <SystemInit+0x3a>
	*DMDATA1 = 0x00;
 746:	e00007b7          	lui	a5,0xe0000
 74a:	0e07ac23          	sw	zero,248(a5) # e00000f8 <_eusrstack+0xbffff8f8>
	*DMDATA0 = 0x80;
 74e:	08000713          	li	a4,128
 752:	0ee7aa23          	sw	a4,244(a5)
	SetupUART( UART_BRR );
#endif
#if defined( FUNCONF_USE_DEBUGPRINTF ) && FUNCONF_USE_DEBUGPRINTF
	SetupDebugPrintf();
#endif
}
 756:	8082                	ret

00000758 <main>:



/*** Main ********************************************************************/
int main(void)
{
 758:	1161                	addi	sp,sp,-8
 75a:	c206                	sw	ra,4(sp)
 75c:	c022                	sw	s0,0(sp)
static void pwm_init(void)
{
	// NOTE: Uses TIM2 Channel 3 (PC0) as the PWM Output pin

	// Enable TIM2 Clock
	RCC->APB1PCENR |= RCC_APB1Periph_TIM2;
 75e:	40021437          	lui	s0,0x40021
	SystemInit();
 762:	374d                	jal	704 <SystemInit>
	RCC->APB1PCENR |= RCC_APB1Periph_TIM2;
 764:	4c5c                	lw	a5,28(s0)

	// Set GPIO OUTPUT 10MHz, Aleternate Function (Multiplex)
	gpio_set_mode(GPIO_PC0, OUTPUT_10MHZ_PP | OUTPUT_PP_AF);
 766:	45a5                	li	a1,9
 768:	4509                	li	a0,2
	RCC->APB1PCENR |= RCC_APB1Periph_TIM2;
 76a:	0017e793          	ori	a5,a5,1
 76e:	cc5c                	sw	a5,28(s0)
	gpio_set_mode(GPIO_PC0, OUTPUT_10MHZ_PP | OUTPUT_PP_AF);
 770:	3e49                	jal	302 <gpio_set_mode>

	// Reset TIM2, Inits all registers
	RCC->APB1PRSTR |= RCC_APB1Periph_TIM2;
 772:	481c                	lw	a5,16(s0)
	RCC->APB1PRSTR &= ~RCC_APB1Periph_TIM2;

	// Set Prescaler to ~17KHz. More efficient switching
	TIM2->PSC = 0x000A;
 774:	4729                	li	a4,10
	// Set the Sample Register(s) for all channels at once
	GPIO_ADC1->SAMPTR1 = cycles;
	GPIO_ADC1->SAMPTR2 = cycles;

	// Enable the ADC, and set the triggering to external
	GPIO_ADC1->CTLR2 |= ADC_ADON | ADC_EXTSEL;
 776:	000e06b7          	lui	a3,0xe0
	RCC->APB1PRSTR |= RCC_APB1Periph_TIM2;
 77a:	0017e793          	ori	a5,a5,1
 77e:	c81c                	sw	a5,16(s0)
	RCC->APB1PRSTR &= ~RCC_APB1Periph_TIM2;
 780:	481c                	lw	a5,16(s0)
 782:	0685                	addi	a3,a3,1 # e0001 <lib_gpioctrl.c.9b7c6186+0xdd1a1>
 784:	9bf9                	andi	a5,a5,-2
 786:	c81c                	sw	a5,16(s0)
	TIM2->PSC = 0x000A;
 788:	400007b7          	lui	a5,0x40000
 78c:	02e79423          	sh	a4,40(a5) # 40000028 <_eusrstack+0x1ffff828>
	// Set PWM Max Value (Autoreload Value)
	TIM2->ATRLR = 254;
 790:	0fe00713          	li	a4,254
 794:	02e79623          	sh	a4,44(a5)

	// Set the Compare Capture Register for Channel 3
	// TIM2_OC3M = 0b111 - PWM Mode 2 - Enable Preload
	TIM2->CHCTLR2 |= TIM_OC3M_2 | TIM_OC3M_1 | TIM_OC3M_0 | TIM_OC3PE;
 798:	01c7d703          	lhu	a4,28(a5)
 79c:	07876713          	ori	a4,a4,120
 7a0:	00e79e23          	sh	a4,28(a5)

	// Enable auto-reload
	TIM2->CTLR1 |= TIM_ARPE;
 7a4:	0007d703          	lhu	a4,0(a5)
 7a8:	08076713          	ori	a4,a4,128
 7ac:	00e79023          	sh	a4,0(a5)

	// Enable channel output, polarity is ACTIVE_HIGH
	TIM2->CCER |= TIM_CC3E | TIM_CC3P;
 7b0:	0207d703          	lhu	a4,32(a5)
 7b4:	30076713          	ori	a4,a4,768
 7b8:	02e79023          	sh	a4,32(a5)

	// Initialise Counter
	TIM2->SWEVGR |= TIM_UG;
 7bc:	0147d703          	lhu	a4,20(a5)
 7c0:	00176713          	ori	a4,a4,1
 7c4:	00e79a23          	sh	a4,20(a5)

	// Enable TIM2
	TIM2->CTLR1 |= TIM_CEN;
 7c8:	0007d703          	lhu	a4,0(a5)
 7cc:	00176713          	ori	a4,a4,1
 7d0:	00e79023          	sh	a4,0(a5)


__attribute__((always_inline))
static inline void pwm_set_duty(const uint32_t duty)
{
	TIM2->CH3CVR = duty;
 7d4:	0207ae23          	sw	zero,60(a5)
	GPIO_RCC->APB2PCENR |= RCC_APB2Periph_ADC1;
 7d8:	4c1c                	lw	a5,24(s0)
	GPIO_RCC->CFGR0 &= ~ADC_CLOCK_DIV_128;
 7da:	7741                	lui	a4,0xffff0
 7dc:	7ff70713          	addi	a4,a4,2047 # ffff07ff <_eusrstack+0xdffeffff>
	GPIO_RCC->APB2PCENR |= RCC_APB2Periph_ADC1;
 7e0:	2007e793          	ori	a5,a5,512
 7e4:	cc1c                	sw	a5,24(s0)
	GPIO_RCC->CFGR0 &= ~ADC_CLOCK_DIV_128;
 7e6:	405c                	lw	a5,4(s0)
 7e8:	8ff9                	and	a5,a5,a4
 7ea:	c05c                	sw	a5,4(s0)
	GPIO_RCC->CFGR0 |= div;
 7ec:	405c                	lw	a5,4(s0)
	GPIO_ADC1->SAMPTR1 = cycles;
 7ee:	24925737          	lui	a4,0x24925
 7f2:	92470713          	addi	a4,a4,-1756 # 24924924 <_eusrstack+0x4924124>
	GPIO_RCC->CFGR0 |= div;
 7f6:	c05c                	sw	a5,4(s0)
	GPIO_RCC->APB2PRSTR |=  RCC_APB2Periph_ADC1;
 7f8:	445c                	lw	a5,12(s0)
 7fa:	2007e793          	ori	a5,a5,512
 7fe:	c45c                	sw	a5,12(s0)
	GPIO_RCC->APB2PRSTR &= ~RCC_APB2Periph_ADC1;
 800:	445c                	lw	a5,12(s0)
 802:	dff7f793          	andi	a5,a5,-513
 806:	c45c                	sw	a5,12(s0)
	GPIO_ADC1->RSQR1 = 0;
 808:	400127b7          	lui	a5,0x40012
 80c:	40078793          	addi	a5,a5,1024 # 40012400 <_eusrstack+0x20011c00>
 810:	0207a623          	sw	zero,44(a5)
	GPIO_ADC1->RSQR2 = 0;
 814:	0207a823          	sw	zero,48(a5)
	GPIO_ADC1->RSQR3 = 0;
 818:	0207aa23          	sw	zero,52(a5)
	GPIO_ADC1->SAMPTR1 = cycles;
 81c:	c7d8                	sw	a4,12(a5)
	GPIO_ADC1->SAMPTR2 = cycles;
 81e:	cb98                	sw	a4,16(a5)
	GPIO_ADC1->CTLR2 |= ADC_ADON | ADC_EXTSEL;
 820:	4798                	lw	a4,8(a5)
 822:	8f55                	or	a4,a4,a3
 824:	c798                	sw	a4,8(a5)
	
	// Reset calibration, wait for it to finish
	GPIO_ADC1->CTLR2 |= ADC_RSTCAL;
 826:	4798                	lw	a4,8(a5)
 828:	00876713          	ori	a4,a4,8
 82c:	c798                	sw	a4,8(a5)
	while(GPIO_ADC1->CTLR2 & ADC_RSTCAL);
 82e:	4798                	lw	a4,8(a5)
 830:	8b21                	andi	a4,a4,8
 832:	ff75                	bnez	a4,82e <main+0xd6>

	// Calibrate the ADC, want for it to finish
	GPIO_ADC1->CTLR2 |= ADC_CAL;
 834:	4798                	lw	a4,8(a5)
 836:	00476713          	ori	a4,a4,4
 83a:	c798                	sw	a4,8(a5)
	while(GPIO_ADC1->CTLR2 & ADC_CAL);
 83c:	40012737          	lui	a4,0x40012
 840:	40070713          	addi	a4,a4,1024 # 40012400 <_eusrstack+0x20011c00>
 844:	471c                	lw	a5,8(a4)
 846:	8b91                	andi	a5,a5,4
 848:	fff5                	bnez	a5,844 <main+0xec>
	gpio_set_mode(OPAMP_CHA1_NEG, INPUT_FLOATING);
 84a:	4591                	li	a1,4
 84c:	10000513          	li	a0,256
 850:	3c4d                	jal	302 <gpio_set_mode>
	gpio_set_mode(OPAMP_CHA1_POS, INPUT_FLOATING);
 852:	4591                	li	a1,4
 854:	20000513          	li	a0,512
 858:	346d                	jal	302 <gpio_set_mode>
	gpio_set_mode(OPAMP_CHA2_POS, INPUT_FLOATING);
 85a:	4591                	li	a1,4
 85c:	70300513          	li	a0,1795
 860:	344d                	jal	302 <gpio_set_mode>
	gpio_set_mode(THERM_ADC_PIN,  INPUT_ANALOG);
 862:	4581                	li	a1,0
 864:	50300513          	li	a0,1283
 868:	3c69                	jal	302 <gpio_set_mode>
	gpio_set_mode(BSENS_ADC_PIN,  INPUT_ANALOG);
 86a:	4581                	li	a1,0
 86c:	60300513          	li	a0,1539
 870:	3c49                	jal	302 <gpio_set_mode>
	gpio_set_mode(OPAMP_ADC_PIN,  INPUT_ANALOG);	
 872:	4581                	li	a1,0
 874:	40300513          	li	a0,1027
 878:	3469                	jal	302 <gpio_set_mode>
	GPIO_EXTEN->EXTEN_CTR |= GPIO_EXTEN_OPA_EN;
 87a:	400247b7          	lui	a5,0x40024
 87e:	80078793          	addi	a5,a5,-2048 # 40023800 <_eusrstack+0x20023000>
 882:	4398                	lw	a4,0(a5)
 884:	66c1                	lui	a3,0x10
 886:	8f55                	or	a4,a4,a3
 888:	c398                	sw	a4,0(a5)
		(GPIO_EXTEN->EXTEN_CTR & ~GPIO_EXTEN_OPA_PSEL) |
 88a:	4398                	lw	a4,0(a5)
 88c:	fffc06b7          	lui	a3,0xfffc0
 890:	16fd                	addi	a3,a3,-1 # fffbffff <_eusrstack+0xdffbf7ff>
 892:	8f75                	and	a4,a4,a3
	GPIO_EXTEN->EXTEN_CTR =
 894:	c398                	sw	a4,0(a5)
		(GPIO_EXTEN->EXTEN_CTR & ~GPIO_EXTEN_OPA_NSEL) |
 896:	4398                	lw	a4,0(a5)
 898:	7681                	lui	a3,0xfffe0
 89a:	16fd                	addi	a3,a3,-1 # fffdffff <_eusrstack+0xdffdf7ff>
 89c:	8f75                	and	a4,a4,a3
	GPIO_EXTEN->EXTEN_CTR =
 89e:	c398                	sw	a4,0(a5)
	SysTick->CTLR = 0x0000;
 8a0:	e000f7b7          	lui	a5,0xe000f
	SysTick->CMP = SYSTICK_ONE_MILLISECOND - 1;
 8a4:	6731                	lui	a4,0xc
	SysTick->CTLR = 0x0000;
 8a6:	0007a023          	sw	zero,0(a5) # e000f000 <_eusrstack+0xc000e800>
	SysTick->CMP = SYSTICK_ONE_MILLISECOND - 1;
 8aa:	b7f70713          	addi	a4,a4,-1153 # bb7f <lib_gpioctrl.c.9b7c6186+0x8d1f>
 8ae:	cb98                	sw	a4,16(a5)
	SysTick->CNT = 0x00000000;
 8b0:	0007a423          	sw	zero,8(a5)
	g_systick_millis = 0x00000000;
 8b4:	c001a223          	sw	zero,-1020(gp) # 20000000 <g_systick_millis>
	SysTick->CTLR |= SYSTICK_CTLR_STE   |  // Enable Counter
 8b8:	4398                	lw	a4,0(a5)
 8ba:	00776713          	ori	a4,a4,7
 8be:	c398                	sw	a4,0(a5)
	NVIC->IENR[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F));
 8c0:	e000e7b7          	lui	a5,0xe000e
 8c4:	6705                	lui	a4,0x1
 8c6:	10e7a023          	sw	a4,256(a5) # e000e100 <_eusrstack+0xc000d900>
inline uint16_t gpio_analog_read(const GPIO_ANALOG_CHANNEL chan)
{
	// Set rule channel conversion for single conversion on passed channel
	// GPIO_ADC1->RSQR1 = 0;
	// GPIO_ADC1->RSQR2 = 0;
	GPIO_ADC1->RSQR3 = (uint32_t)chan;
 8ca:	400127b7          	lui	a5,0x40012
 8ce:	40078793          	addi	a5,a5,1024 # 40012400 <_eusrstack+0x20011c00>
 8d2:	4715                	li	a4,5
 8d4:	dbd8                	sw	a4,52(a5)

	GPIO_ADC1->CTLR2 |= ADC_SWSTART;
 8d6:	4798                	lw	a4,8(a5)
 8d8:	004006b7          	lui	a3,0x400
 8dc:	8f55                	or	a4,a4,a3
 8de:	c798                	sw	a4,8(a5)
	while(!(GPIO_ADC1->STATR & ADC_EOC));
 8e0:	4398                	lw	a4,0(a5)
 8e2:	8b09                	andi	a4,a4,2
 8e4:	df75                	beqz	a4,8e0 <main+0x188>

	// Get the resulting data from the ADC
	return GPIO_ADC1->RDATAR;
 8e6:	47ec                	lw	a1,76(a5)
		printf("%d\n", gpio_analog_read(THERM_ADC_CH));
 8e8:	6505                	lui	a0,0x1
 8ea:	94050513          	addi	a0,a0,-1728 # 940 <SysTick_Handler+0x32>
 8ee:	05c2                	slli	a1,a1,0x10
 8f0:	81c1                	srli	a1,a1,0x10
 8f2:	3bc5                	jal	6e2 <printf>
	uint32_t targend = SysTick->CNT + n;
 8f4:	e000f6b7          	lui	a3,0xe000f
 8f8:	4698                	lw	a4,8(a3)
 8fa:	016e37b7          	lui	a5,0x16e3
 8fe:	60078793          	addi	a5,a5,1536 # 16e3600 <lib_gpioctrl.c.9b7c6186+0x16e07a0>
 902:	973e                	add	a4,a4,a5
	while( ((int32_t)( SysTick->CNT - targend )) < 0 );
 904:	469c                	lw	a5,8(a3)
 906:	8f99                	sub	a5,a5,a4
 908:	fe07cee3          	bltz	a5,904 <main+0x1ac>
 90c:	bf7d                	j	8ca <main+0x172>

0000090e <SysTick_Handler>:
{
 90e:	1151                	addi	sp,sp,-12
 910:	c03e                	sw	a5,0(sp)
	SysTick->CMP += SYSTICK_ONE_MILLISECOND;
 912:	e000f7b7          	lui	a5,0xe000f
{
 916:	c23a                	sw	a4,4(sp)
	SysTick->CMP += SYSTICK_ONE_MILLISECOND;
 918:	4b98                	lw	a4,16(a5)
{
 91a:	c436                	sw	a3,8(sp)
	SysTick->CMP += SYSTICK_ONE_MILLISECOND;
 91c:	66b1                	lui	a3,0xc
 91e:	b8068693          	addi	a3,a3,-1152 # bb80 <lib_gpioctrl.c.9b7c6186+0x8d20>
 922:	9736                	add	a4,a4,a3
 924:	cb98                	sw	a4,16(a5)
	SysTick->SR = 0x00000000;
 926:	0007a223          	sw	zero,4(a5) # e000f004 <_eusrstack+0xc000e804>
	g_systick_millis++;
 92a:	c041a783          	lw	a5,-1020(gp) # 20000000 <g_systick_millis>
}
 92e:	46a2                	lw	a3,8(sp)
	g_systick_millis++;
 930:	0785                	addi	a5,a5,1
 932:	c0f1a223          	sw	a5,-1020(gp) # 20000000 <g_systick_millis>
}
 936:	4712                	lw	a4,4(sp)
 938:	4782                	lw	a5,0(sp)
 93a:	0131                	addi	sp,sp,12
 93c:	30200073          	mret
 940:	6425                	lui	s0,0x9
 942:	000a                	c.slli	zero,0x2

00000944 <GPIO_PORT_MAP>:
 944:	0800 4001 0000 0000 1000 4001 1400 4001     ...@.......@...@
